
















'use client'

import { useEffect, useRef, useState } from "react";
import * as THREE from 'three';
import { HexColorPicker } from "react-colorful"; // For the color picker
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

const ThreeScene: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [color, setColor] = useState("#ffffff"); // Initial color (white)

  useEffect(() => {
    if (typeof window !== 'undefined') {
      // Scene, camera, renderer setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 10;
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      containerRef.current?.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false; // Lock pan
      controls.enableZoom = true; // Allow zoom
      controls.enableRotate = true; // Allow rotation
      controls.maxPolarAngle = Math.PI / 2; // Horizontal rotation only
      controls.minPolarAngle = Math.PI / 2;

      // Load the GLTF model
      const loader = new GLTFLoader();
      loader.load('/bilco5.glb', (gltf) => {
        const model = gltf.scene.children[0];

              // Compute bounding box to center the model
      // const box = new THREE.Box3().setFromObject(model);
      // const center = new THREE.Vector3();
      // box.getCenter(center);
      // model; // Move model to center
      console.log(model);
      

      // Scale the model to fit in the view (if needed)
      // const size = box.getSize(new THREE.Vector3());
      // const maxDimension = Math.max(size.x, size.y, size.z);
      // model.scale.setScalar(5); // Scale down if too large

        // Load normal map texture
        const normalMap = new THREE.TextureLoader().load('/brick-texture.png');
        scene.background = new THREE.Color('#000000')

        // Apply a dynamic color with the normal map
        // model.traverse((child) => {
        //   if (child.isMesh) {
            // model.material = new THREE.MeshStandardMaterial({
            //   color: new THREE.Color(color), // Initial color
            //   normalMap: normalMap, // Apply the normal map
            // });
            model.castShadow = true;
            model.receiveShadow = true;
          // }
        // });

        // const sphere = new THREE.Mesh(
        //   new THREE.SphereGeometry(1, 50, 50),
        //   new THREE.MeshStandardMaterial()
        // );

        // sphere.position.x = 0;
        // scene.add(sphere);

        scene.add(model);
        animate();
      });

      // Lighting setup (can be changed dynamically)
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 5, 5);
      scene.add(light);

      // Animate and render loop
      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };
    }
  }, [color]); // Re-render when color changes

  // Color picker onChange handler
  const handleColorChange = (newColor) => {
    setColor(newColor); // Update the color state, causing the effect to re-run
  };

  return (
    <>
      <div ref={containerRef} style={{ width: '100%', height: '500px' }} />
      <HexColorPicker color={color} onChange={handleColorChange} />
    </>
  );
};

export default ThreeScene;
